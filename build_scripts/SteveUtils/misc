string $sel[] = `ls -sl` ;
for ($s in $sel) {
    lockNode -l off $s ;
}
##HIveUnlock


##BulkAddAttr

import maya.cmds as mc

def add_attributes():
    selected_objs = mc.ls(selection=True)
    if not selected_objs:
        print("No objects selected.")
        return
    
    attr_list = input("Enter the attribute names separated by spaces: ").split()
    
    for obj in selected_objs:
        for attr in attr_list:
            mc.addAttr(longName=attr, attributeType='float', keyable=True, min=0, max=1)

add_attributes()


## Grab offset groups

import maya.cmds as mc

# Select all objects that match the pattern 'Express_Offset*'
name = input()
mc.select(name + '*')
selected_objects = mc.ls(selection=True)

# List of substrings to filter out
filter_substrings = [
    '_rotateX', '_rotateY', '_rotateZ',
    '_scaleX', '_scaleY', '_scaleZ',
    '_translateX', '_translateY', '_translateZ'
]

# Filter out objects that contain any of the filter substrings
filtered_objects = [
    obj for obj in selected_objects if not any(sub in obj for sub in filter_substrings)
]

# Update the selection with the filtered objects
mc.select(filtered_objects)


## retargetPlugin

import animation_retargeting_tool

animation_retargeting_tool.start()


##PickerPlugin
import dwpicker
dwpicker.show()

## model checker
from modelChecker import modelChecker_UI

modelChecker_UI.UI.show_UI()

##gs curve tools
import gs_curvetools.init as ct_init;from imp import reload;reload(ct_init);ct_init.Init();

## Get Children List
import maya.cmds as cmds

def get_objects_in_group(group_name):
    if cmds.objExists(group_name) and cmds.nodeType(group_name) == 'transform':
        children = cmds.listRelatives(group_name, children=True, fullPath=True) or []
        object_list = [child.split('|')[-1] for child in children if cmds.objectType(child) in ['transform', 'mesh', 'nurbsCurve', 'joint']]
        print("Objects in '{}':".format(group_name), object_list)
        return object_list
    else:
        print("Group '{}' does not exist or is not a transform node.".format(group_name))
        return []

# Run the function
group_name = input()
objects = get_objects_in_group(group_name)


#MEL command to combine multiple curve shapes into one curve object
    #selece a null transform, then all of the shapes (not just the transfrom)
parent -r -s 


## Launches UE pose editor
from epic_pose_wrangler import main
pose_wrangler = main.PoseWrangler()




## Grab Parents of Selected and prints it as a list 

import maya.cmds as cmds

def print_selected_objects():
    selection = cmds.ls(selection=True)
    if selection:
        return selection
    #    print("Selected objects:")
    #    print(selection)
    else:
        print("No objects selected.")

# Run the function
print_selected_objects()


def get_parents(object_list):
    parent_list = []
    for obj in object_list:
        parent = cmds.listRelatives(obj, parent=True)
        if parent:
            parent_list.append(parent[0])
        else:
            parent_list.append(None)  # No parent (probably a top node)
    return parent_list

# Example usage:
# Replace this list with your own or connect it to a selection
#example_list = ['Body_sculpt_02BackM_ctrl', 'Body_sculpt_02FrontR_ctrl', 'Body_sculpt_04BackR_ctrl', 'Body_sculpt_01legL_ctrl', 'Body_sculpt_02ShdrR_ctrl', 'Body_sculpt_04RShoulder_ctrl', 'Body_sculpt_02BackL_ctrl', 'Body_sculpt_05FrontM_ctrl', 'Body_sculpt_03BackR_ctrl', 'Body_sculpt_04FrontM_ctrl', 'Body_sculpt_02SideR_ctrl', 'Body_sculpt_06BackM_ctrl', 'Body_sculpt_02BackR_ctrl', 'Body_sculpt_02FrontM_ctrl', 'Body_sculpt_06ShdrR_ctrl', 'Body_sculpt_03FrontM_ctrl', 'Body_sculpt_03legR_ctrl', 'Body_sculpt_05BackM_ctrl', 'Body_sculpt_05FrontR_ctrl', 'Body_sculpt_02FrontL_ctrl', 'Body_sculpt_06FrontR_ctrl', 'Body_sculpt_01ShdrR_ctrl', 'Body_sculpt_01FrontL_ctrl', 'Body_sculpt_03BackL_ctrl', 'Body_sculpt_01BackR_ctrl', 'Body_sculpt_03BackM_ctrl', 'Body_sculpt_01SideL_ctrl', 'Body_sculpt_02legR_ctrl', 'Body_sculpt_03ClavR_ctrl', 'Body_sculpt_02SideL_ctrl', 'Body_sculpt_04FrontL_ctrl', 'Body_sculpt_02Under_ctrl', 'Body_sculpt_01SideR_ctrl', 'Body_sculpt_01BackL_ctrl', 'Body_sculpt_05BackL_ctrl', 'Body_sculpt_02ClavL_ctrl', 'Body_sculpt_09BackM_ctrl', 'Body_sculpt_05ShdrR_ctrl', 'Body_sculpt_08BackM_ctrl', 'Body_sculpt_03FrontR_ctrl', 'Body_sculpt_04BackL_ctrl', 'Body_sculpt_03ShdrL_ctrl', 'Body_sculpt_03SideR_ctrl', 'Body_sculpt_07BackM_ctrl', 'Body_sculpt_03legL_ctrl', 'Body_sculpt_06FrontL_ctrl', 'Body_sculpt_03Under_ctrl', 'Body_sculpt_01BackM_ctrl', 'Body_sculpt_06FrontM_ctrl', 'Body_sculpt_01legR_ctrl', 'Body_sculpt_03SideL_ctrl', 'Body_sculpt_06ShdrL_ctrl', 'Body_sculpt_02legL_ctrl', 'Body_sculpt_05FrontL_ctrl', 'Body_sculpt_03ShdrR_ctrl', 'Body_sculpt_01FrontR_ctrl', 'Body_sculpt_01Under_ctrl', 'Body_sculpt_07FrontM_ctrl', 'Body_sculpt_03FrontL_ctrl', 'Body_sculpt_05BackR_ctrl', 'Body_sculpt_02ClavR_ctrl', 'Body_sculpt_05ShdrL_ctrl', 'Body_sculpt_04FrontR_ctrl', 'Body_sculpt_01FrontM_ctrl', 'Body_sculpt_03ClavL_ctrl', 'Body_sculpt_02ShdrL_ctrl', 'Body_sculpt_04BackM_ctrl', 'Body_sculpt_01ClavR_ctrl', 'Body_sculpt_01ClavL_ctrl']
Selected_objects = print_selected_objects()
parents = get_parents(Selected_objects)
print("Selected Objects:", Selected_objects)
print("Parent list:", parents)



#Write Contols
import rjg.post.dataIO.controls as rCtrlIO
import rjg.libs.control.draw as draw

rCtrlIO.write_ctrls("G:/bobo/character/Rigs/Bobo/Controls", force=True, name='bobo_control_curves')

#Print Selection as a List
import maya.cmds as mc

def print_selected_list():
    selection = mc.ls(selection=True)
    print(selection)

# Run it
print_selected_list()


import rjg.build_scripts.SteveUtils.RibbonUtilsMenu as rib 
rib.show_ribbon_utils()



#ShotSculpt for anim

import rjg.libs.shotSculpt as ss; ss.setupMenu();import rjg.libs.shotSculpt as ss; ss.setupMenu();

from rjg.libs.softMod import *; from rjg.libs.softMod import ui as smui; smui();



#Print All Channels

import maya.cmds as mc

def print_all_channels(obj):
    if not mc.objExists(obj):
        print(f"Object '{obj}' does not exist.")
        return

    print(f"--- Channels for: {obj} ---")

    # Keyable channels
    keyable_attrs = mc.listAttr(obj, keyable=True) or []
    print("Keyable Attributes:")
    for attr in keyable_attrs:
        print(f"  {attr}")

    # Non-keyable but visible attributes
    visible_attrs = mc.listAttr(obj, channelBox=True) or []
    print("Channel Box Only Attributes:")
    for attr in visible_attrs:
        if attr not in keyable_attrs:
            print(f"  {attr}")

    # All user-defined attributes
    user_attrs = mc.listAttr(obj, userDefined=True) or []
    if user_attrs:
        print("User-Defined Attributes:")
        for attr in user_attrs:
            print(f"  {attr}")

# Run the function on the currently selected object
selection = mc.ls(selection=True)
if selection:
    print_all_channels(selection[0])
else:
    print("Please select an object.")


#from guide build joint matches translation rotate and adopts name, so M_hand1_guide2 will become M_hand1_2_jnt

import maya.cmds as mc

def create_joints_from_guides():
    selection = mc.ls(sl=True, long=True)
    if not selection:
        mc.warning("Nothing selected.")
        return

    created_joints = []

    for obj in selection:
        # Get the base name and generate joint name
        base_name = obj.split('|')[-1].replace('guide', '')
        joint_name = f"{base_name}_jnt"

        # Clear selection before creating the joint to avoid parenting
        mc.select(clear=True)
        joint = mc.joint(name=joint_name)
        created_joints.append(joint)

        # Match translation and rotation in world space
        pos = mc.xform(obj, q=True, ws=True, t=True)
        rot = mc.xform(obj, q=True, ws=True, ro=True)
        mc.xform(joint, ws=True, t=pos)
        mc.xform(joint, ws=True, ro=rot)

    mc.select(created_joints)
    print(f"Created joints: {created_joints}")

# Run it
create_joints_from_guides()


#Bulk Control to jnt constrain 

import maya.cmds as mc

def constrain_controls_to_joints(ctrl_suffix="_ctrl", jnt_suffix="_jnt"):
    selection = mc.ls(sl=True, long=True)
    if not selection:
        mc.warning("No controls selected.")
        return

    for ctrl in selection:
        short_name = ctrl.split('|')[-1]

        if not short_name.endswith(ctrl_suffix):
            mc.warning(f"Skipped: {short_name} does not end with expected suffix '{ctrl_suffix}'")
            continue

        # Replace suffix to get joint name
        joint_name = short_name.replace(ctrl_suffix, jnt_suffix)

        # Check if joint exists by short name
        joint = mc.ls(joint_name, type="joint")
        if not joint:
            mc.warning(f"Joint not found for control: {short_name} → {joint_name}")
            continue

        joint = joint[0]  # Get the full path if needed

        # Apply constraints
        try:
            mc.parentConstraint(ctrl, joint, mo=True)
            mc.scaleConstraint(ctrl, joint, mo=True)
            print(f"Constrained {joint} to {ctrl}")
        except Exception as e:
            mc.warning(f"Constraint failed for {ctrl} → {joint}: {e}")

# Example usage:
constrain_controls_to_joints(ctrl_suffix="_ctrl", jnt_suffix="_jnt")


#bulk mirror joints

import maya.cmds as mc

def mirror_selected_joints(mirror_type='behavior', search_for='L_', replace_with='R_', mirror_across='yz'):
    """
    Mirrors selected joints with customizable mirror type, naming, and mirror axis.

    Args:
        mirror_type (str): 'behavior' or 'orientation'
        search_for (str): Substring to search for in joint names (e.g., 'L_')
        replace_with (str): Substring to replace with (e.g., 'R_')
        mirror_across (str): Axis to mirror across: 'xy', 'yz', or 'xz' (default: 'yz')
    """
    mirror_type = mirror_type.lower()
    mirror_across = mirror_across.lower()

    # Validate mirror_type
    if mirror_type not in ['behavior', 'orientation']:
        mc.warning("mirror_type must be 'behavior' or 'orientation'")
        return

    # Map axis strings to mirror flags
    mirror_plane_flags = {
        'xy': (True, False, False),
        'yz': (False, True, False),
        'xz': (False, False, True),
    }

    if mirror_across not in mirror_plane_flags:
        mc.warning("mirror_across must be one of: 'xy', 'yz', 'xz'")
        return

    mirrorXY, mirrorYZ, mirrorXZ = mirror_plane_flags[mirror_across]

    selection = mc.ls(sl=True, type='joint')
    if not selection:
        mc.warning("No joints selected.")
        return

    mirrored_joints = []

    for joint in selection:
        try:
            mirrored = mc.mirrorJoint(
                joint,
                mirrorBehavior=(mirror_type == 'behavior'),
                mirrorXY=mirrorXY,
                mirrorYZ=mirrorYZ,
                mirrorXZ=mirrorXZ,
                searchReplace=(search_for, replace_with)
            )

            if mirrored:
                mirrored_joints.extend(mirrored)
                print(f"Mirrored {joint} to {mirrored[0]}")
            else:
                mc.warning(f"Failed to mirror {joint}")

        except Exception as e:
            mc.warning(f"Error mirroring {joint}: {e}")

    mc.select(mirrored_joints, replace=True)

# 🔧 Example usage:
mirror_selected_joints(mirror_type='behavior', search_for='L_', replace_with='R_', mirror_across='yz')


import sys
modules = [name for name in sys.modules.keys() if name.startswith("rjg")]
for name in modules:
    del sys.modules[name]
import rjg






import maya.cmds as mc

def create_driver_joints(default_mult=10.0, ctrl_suffix="_CTRL", joint_suffix="_Driver"):
    selected_controls = mc.ls(selection=True, type="transform")

    if not selected_controls:
        mc.warning("No controls selected.")
        return

    for ctrl in selected_controls:
        # Add DriverMult attribute
        if not mc.attributeQuery("DriverMult", node=ctrl, exists=True):
            mc.addAttr(ctrl, longName="DriverMult", attributeType="double", defaultValue=default_mult, keyable=True)

        # Get position of control
        pos = mc.xform(ctrl, query=True, worldSpace=True, translation=True)

        # Create joint at world position, don't inherit rotation
        base_name = ctrl.replace(ctrl_suffix, "")
        joint_name = base_name + joint_suffix

        mc.select(clear=True)
        driver_joint = mc.joint(name=joint_name, position=pos)
        mc.setAttr(driver_joint + ".rotate", 0, 0, 0)
        mc.setAttr(driver_joint + ".radius", 0.1)
        mc.makeIdentity(driver_joint, apply=True, t=1, r=1, s=1, n=0)

        # Create multiplyDivide node
        mult_node = mc.createNode("multiplyDivide", name=f"{base_name}_DriverMult_node")

        # Connect control translate to multiplyDivide input1
        mc.connectAttr(ctrl + ".translateX", mult_node + ".input1X", force=True)
        mc.connectAttr(ctrl + ".translateY", mult_node + ".input1Y", force=True)
        mc.connectAttr(ctrl + ".translateZ", mult_node + ".input1Z", force=True)

        # Connect DriverMult to input2 (all axes)
        mc.connectAttr(ctrl + ".DriverMult", mult_node + ".input2X", force=True)
        mc.connectAttr(ctrl + ".DriverMult", mult_node + ".input2Y", force=True)
        mc.connectAttr(ctrl + ".DriverMult", mult_node + ".input2Z", force=True)

        # Connect output of mult to joint rotation
        mc.connectAttr(mult_node + ".outputX", driver_joint + ".rotateX", force=True)
        mc.connectAttr(mult_node + ".outputY", driver_joint + ".rotateY", force=True)
        mc.connectAttr(mult_node + ".outputZ", driver_joint + ".rotateZ", force=True)

    print("✅ Driver joints created successfully.")



create_driver_joints(default_mult=10.0, ctrl_suffix="_CTRL", joint_suffix="_Driver")


